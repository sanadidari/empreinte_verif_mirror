#!/usr/bin/env python3
# tools/titan_engine.py
# TITAN MODE — Autonomous DevOps Intelligence
# Full-cycle decision and execution engine.

import json, datetime, subprocess, os, random
from pathlib import Path

def load(path, default=None):
    if Path(path).exists():
        return json.load(open(path, "r", encoding="utf-8"))
    return default

def write(path, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)

def run(cmd):
    print("+", cmd)
    out = subprocess.run(cmd, shell=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return out.stdout.strip(), out.stderr.strip(), out.returncode

def choose_action(rcdb, corr, report, orders):
    actions = []

    # If Governor freeze → TITAN respects
    if orders and orders.get("actions"):
        freeze = [a for a in orders["actions"] if a["type"] == "freeze"]
        if freeze:
            return "idle"  # TITAN forced to idle

    # High-impact cluster → TITAN must repair
    if corr and corr.get("clusters"):
        biggest = corr["clusters"][0]
        if biggest["count"] >= 4:
            return "auto_repair"

    # Repeated workflow failures → rewrite
    if "Repeated Workflow Failures" in str(report):
        return "rewrite_workflow"

    # Stable system → develop feature
    if orders and orders.get("stability_score", 100) > 85:
        return "generate_feature"

    return "idle"

def titan_auto_repair():
    # Executes: flutter pub get, fix formatting, attempt small build. (No UI)
    run("flutter pub get || true")
    run("dart fix --apply || true")
    run("dart format . || true")
    return "repair_complete"

def titan_rewrite_workflow():
    # Re-run the AWR on demand
    run("python tools/workflow_rewriter.py --workflows .github/workflows --rcdb docs/ROOT_CAUSE_DB.json --corr docs/ROOT_CAUSE_CORRELATIONS.json --report docs/SUPERVISOR_REPORT.md --out rewrites")
    return "workflow_rewrite_run"

def titan_generate_feature():
    # TITAN generates a small Flutter feature placeholder
    feature_name = f"titan_feature_{random.randint(1000,9999)}"
    path = Path(f"lib/{feature_name}.dart")

    content = f"""
import 'package:flutter/material.dart';

class {feature_name.capitalize()} extends StatelessWidget {{
  @override
  Widget build(BuildContext context) {{
    return Scaffold(
      appBar: AppBar(title: Text('{feature_name}')),
      body: Center(child: Text('Generated by TITAN Mode')),
    );
  }}
}}
"""
    path.write_text(content, encoding="utf-8")

    run("dart format lib")
    return f"feature_generated:{feature_name}"

def main():
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument("--policy", required=True)
    p.add_argument("--state", required=True)
    p.add_argument("--rcdb", required=True)
    p.add_argument("--corr", required=True)
    p.add_argument("--report", required=True)
    p.add_argument("--orders", required=True)
    p.add_argument("--out", required=True)
    args = p.parse_args()

    rcdb = load(args.rcdb, {})
    corr = load(args.corr, {})
    state = load(args.state, {"history": []})
    report = Path(args.report).read_text() if Path(args.report).exists() else ""
    orders = load(args.orders, {})

    action = choose_action(rcdb, corr, report, orders)

    if action == "auto_repair":
        result = titan_auto_repair()
    elif action == "rewrite_workflow":
        result = titan_rewrite_workflow()
    elif action == "generate_feature":
        result = titan_generate_feature()
    else:
        result = "idle"

    state["last_run"] = datetime.datetime.utcnow().isoformat()
    state["last_action"] = action
    state["history"].append({"time": state["last_run"], "action": action, "result": result})

    write(args.out, state)
    print("TITAN run complete:", action, result)

if __name__ == "__main__":
    main()
